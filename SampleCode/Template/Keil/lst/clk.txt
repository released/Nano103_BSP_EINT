; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Nano103\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;30       */
;;;31     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
;;;32     {
;;;33         /* Disable CKO clock source */
;;;34         CLK->APBCLK &= (~CLK_APBCLK_CLKOCKEN_Msk);
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;35     }
00000a  4770              BX       lr
;;;36     
                          ENDP

                  |L1.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;498      */
;;;499    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  0fc1              LSRS     r1,r0,#31
;;;500    {
;;;501        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  &= ~(1<<MODULE_IP_EN_Pos(u32ModuleIdx));
000002  008a              LSLS     r2,r1,#2
000004  4904              LDR      r1,|L2.24|
000006  1851              ADDS     r1,r2,r1
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2001              MOVS     r0,#1
000010  4098              LSLS     r0,r0,r3
000012  4382              BICS     r2,r2,r0
000014  604a              STR      r2,[r1,#4]
;;;502    }
000016  4770              BX       lr
;;;503    
                          ENDP

                  |L2.24|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;580      */
;;;581    void CLK_DisablePLL(void)
000000  4802              LDR      r0,|L3.12|
;;;582    {
;;;583        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000002  6a41              LDR      r1,[r0,#0x24]
000004  01c2              LSLS     r2,r0,#7
000006  4311              ORRS     r1,r1,r2
000008  6241              STR      r1,[r0,#0x24]
;;;584    }
00000a  4770              BX       lr
;;;585    
                          ENDP

                  |L3.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;633      */
;;;634    void CLK_DisableSysTick(void)
000000  4901              LDR      r1,|L4.8|
;;;635    {
;;;636        SysTick->CTRL = 0;    /* Set System Tick counter disabled */
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;637    }
000006  4770              BX       lr
;;;638    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;426      */
;;;427    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;428    {
;;;429        CLK->PWRCTL &= ~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;430    }
000008  4770              BX       lr
;;;431    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;55       */
;;;56     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  b530              PUSH     {r4,r5,lr}
;;;57     {
;;;58         /* Select CKO clock source */
;;;59         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_CLKOSEL_Msk)) | u32ClkSrc;
000002  4b08              LDR      r3,|L6.36|
000004  699c              LDR      r4,[r3,#0x18]
000006  2570              MOVS     r5,#0x70
000008  43ac              BICS     r4,r4,r5
00000a  4304              ORRS     r4,r4,r0
00000c  619c              STR      r4,[r3,#0x18]
;;;60     
;;;61         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;62         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En<<CLK_CLKOCTL_DIV1EN_Pos);
00000e  0150              LSLS     r0,r2,#5
000010  4308              ORRS     r0,r0,r1
000012  2110              MOVS     r1,#0x10
000014  4308              ORRS     r0,r0,r1
000016  6298              STR      r0,[r3,#0x28]
;;;63     
;;;64         /* Enable CKO clock source */
;;;65         CLK->APBCLK |= CLK_APBCLK_CLKOCKEN_Msk;
000018  6898              LDR      r0,[r3,#8]
00001a  2140              MOVS     r1,#0x40
00001c  4308              ORRS     r0,r0,r1
00001e  6098              STR      r0,[r3,#8]
;;;66     }
000020  bd30              POP      {r4,r5,pc}
;;;67     
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;462      */
;;;463    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  0fc1              LSRS     r1,r0,#31
;;;464    {
;;;465        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  |= 1<<MODULE_IP_EN_Pos(u32ModuleIdx);
000002  008a              LSLS     r2,r1,#2
000004  4904              LDR      r1,|L7.24|
000006  1851              ADDS     r1,r2,r1
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2001              MOVS     r0,#1
000010  4098              LSLS     r0,r0,r3
000012  4302              ORRS     r2,r2,r0
000014  604a              STR      r2,[r1,#4]
;;;466    }
000016  4770              BX       lr
;;;467    
                          ENDP

                  |L7.24|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;512      */
;;;513    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f8              PUSH     {r3-r7,lr}
;;;514    {
000002  4605              MOV      r5,r0
;;;515        uint32_t u32PllCr,u32PLL_N,u32PLL_M,u32PLLReg;
;;;516        if ( u32PllFreq < FREQ_16MHZ)
000004  482f              LDR      r0,|L8.196|
;;;517            u32PllFreq=FREQ_16MHZ;
;;;518        else if(u32PllFreq > FREQ_36MHZ)
000006  4b30              LDR      r3,|L8.200|
000008  460c              MOV      r4,r1                 ;514
00000a  4281              CMP      r1,r0                 ;516
00000c  d201              BCS      |L8.18|
00000e  4604              MOV      r4,r0                 ;517
000010  e002              B        |L8.24|
                  |L8.18|
000012  429c              CMP      r4,r3
000014  d900              BLS      |L8.24|
;;;519            u32PllFreq=FREQ_36MHZ;
000016  461c              MOV      r4,r3
                  |L8.24|
;;;520    
;;;521        if(u32PllClkSrc == CLK_PLLCTL_PLL_SRC_HXT)
;;;522        {
;;;523            /* PLL source clock from HXT */
;;;524            CLK->PLLCTL = (CLK->PLLCTL & ~CLK_PLLCTL_PLL_SRC_HIRC);
;;;525            u32PllCr = __HXT;
000018  4f2c              LDR      r7,|L8.204|
00001a  4e2d              LDR      r6,|L8.208|
00001c  2d00              CMP      r5,#0                 ;521
00001e  d00a              BEQ      |L8.54|
;;;526        }
;;;527        else if(u32PllClkSrc == CLK_PLLCTL_PLL_SRC_HIRC)
000020  0231              LSLS     r1,r6,#8
000022  428d              CMP      r5,r1
000024  d112              BNE      |L8.76|
;;;528        {
;;;529            /* PLL source clock from HIRC */
;;;530            CLK->PLLCTL = (CLK->PLLCTL & ~CLK_PLLCTL_PLL_SRC_HIRC) | (CLK_PLLCTL_PLL_SRC_HIRC);
000026  6a72              LDR      r2,[r6,#0x24]
000028  430a              ORRS     r2,r2,r1
00002a  6272              STR      r2,[r6,#0x24]
;;;531    
;;;532            /* HIRC Source Selection */
;;;533            if(CLK->CLKSEL0 & CLK_CLKSEL0_HIRCSEL_Msk)
00002c  6931              LDR      r1,[r6,#0x10]
00002e  0709              LSLS     r1,r1,#28
000030  d507              BPL      |L8.66|
;;;534            {
;;;535                /* Clock source from HIRC1 (36MHz) */
;;;536                u32PllCr =__HIRC36M;
000032  4618              MOV      r0,r3
000034  e010              B        |L8.88|
                  |L8.54|
000036  6a70              LDR      r0,[r6,#0x24]         ;524
000038  2101              MOVS     r1,#1                 ;524
00003a  0449              LSLS     r1,r1,#17             ;524
00003c  4388              BICS     r0,r0,r1              ;524
00003e  6270              STR      r0,[r6,#0x24]         ;524
000040  e002              B        |L8.72|
                  |L8.66|
;;;537            }
;;;538            else
;;;539            {
;;;540                /* Clock source from HIRC0 (12MHz) */
;;;541                if(CLK->PWRCTL & CLK_PWRCTL_HIRC0FSEL_Msk)
000042  6831              LDR      r1,[r6,#0]
000044  0489              LSLS     r1,r1,#18
000046  d407              BMI      |L8.88|
                  |L8.72|
;;;542                    u32PllCr =__HIRC16M;
;;;543                else
;;;544                    u32PllCr =__HIRC12M;
000048  4638              MOV      r0,r7
00004a  e005              B        |L8.88|
                  |L8.76|
;;;545            }
;;;546        }
;;;547        else
;;;548        {
;;;549            /* PLL source clock from MIRC (4MHz) */
;;;550            CLK->PLLCTL = (CLK->PLLCTL & ~CLK_PLLCTL_PLL_SRC_MIRC) | (CLK_PLLCTL_PLL_SRC_MIRC);
00004c  6a70              LDR      r0,[r6,#0x24]
00004e  2101              MOVS     r1,#1
000050  0489              LSLS     r1,r1,#18
000052  4308              ORRS     r0,r0,r1
000054  6270              STR      r0,[r6,#0x24]
;;;551            u32PllCr =__MIRC;
000056  481f              LDR      r0,|L8.212|
                  |L8.88|
;;;552        }
;;;553    
;;;554        u32PLL_N=u32PllCr/1000000;
000058  491f              LDR      r1,|L8.216|
00005a  f7fffffe          BL       __aeabi_uidivmod
00005e  4607              MOV      r7,r0
;;;555        u32PLL_M=u32PllFreq/1000000;
000060  491d              LDR      r1,|L8.216|
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       __aeabi_uidivmod
                  |L8.104|
;;;556        while(1)
;;;557        {
;;;558            if(u32PLL_M<=48 && u32PLL_N<=36 ) break;
000068  2830              CMP      r0,#0x30
00006a  d801              BHI      |L8.112|
00006c  2f24              CMP      r7,#0x24
00006e  d902              BLS      |L8.118|
                  |L8.112|
;;;559            u32PLL_M >>=1;
000070  0840              LSRS     r0,r0,#1
;;;560            u32PLL_N >>=1;
000072  087f              LSRS     r7,r7,#1
000074  e7f8              B        |L8.104|
                  |L8.118|
;;;561        }
;;;562        u32PLLReg = (u32PLL_M<<CLK_PLLCTL_PLLMLP_Pos) | ((u32PLL_N-1)<<CLK_PLLCTL_INDIV_Pos);
000076  0239              LSLS     r1,r7,#8
000078  39ff              SUBS     r1,r1,#0xff
00007a  3901              SUBS     r1,#1
00007c  4301              ORRS     r1,r1,r0
;;;563        CLK->PLLCTL = ( CLK->PLLCTL & ~(CLK_PLLCTL_PLLMLP_Msk | CLK_PLLCTL_INDIV_Msk ) )| u32PLLReg;
00007e  6a70              LDR      r0,[r6,#0x24]
000080  4a16              LDR      r2,|L8.220|
000082  4010              ANDS     r0,r0,r2
000084  4308              ORRS     r0,r0,r1
000086  6270              STR      r0,[r6,#0x24]
;;;564    
;;;565        if(u32PllClkSrc==CLK_PLLCTL_PLL_SRC_HIRC)
000088  2101              MOVS     r1,#1
;;;566            CLK->PLLCTL = (CLK->PLLCTL & ~CLK_PLLCTL_PLLSRC_Msk) | (CLK_PLLCTL_PLL_SRC_HIRC);
00008a  2003              MOVS     r0,#3
00008c  0449              LSLS     r1,r1,#17             ;565
00008e  0440              LSLS     r0,r0,#17
000090  428d              CMP      r5,r1                 ;565
000092  d103              BNE      |L8.156|
000094  6a72              LDR      r2,[r6,#0x24]
000096  4382              BICS     r2,r2,r0
000098  1850              ADDS     r0,r2,r1
00009a  e006              B        |L8.170|
                  |L8.156|
;;;567        else if(u32PllClkSrc==CLK_PLLCTL_PLL_SRC_HXT)
;;;568            CLK->PLLCTL = (CLK->PLLCTL & ~CLK_PLLCTL_PLLSRC_Msk) | (CLK_PLLCTL_PLL_SRC_HXT);
;;;569        else
;;;570            CLK->PLLCTL = (CLK->PLLCTL & ~CLK_PLLCTL_PLLSRC_Msk) | (CLK_PLLCTL_PLL_SRC_MIRC);
00009c  6a71              LDR      r1,[r6,#0x24]
00009e  2d00              CMP      r5,#0                 ;567
0000a0  d00c              BEQ      |L8.188|
0000a2  4381              BICS     r1,r1,r0
0000a4  2001              MOVS     r0,#1
0000a6  0480              LSLS     r0,r0,#18
0000a8  1808              ADDS     r0,r1,r0
                  |L8.170|
0000aa  6270              STR      r0,[r6,#0x24]
                  |L8.172|
;;;571    
;;;572        CLK->PLLCTL &= ~CLK_PLLCTL_PD_Msk;
0000ac  6a70              LDR      r0,[r6,#0x24]
0000ae  2101              MOVS     r1,#1
0000b0  0409              LSLS     r1,r1,#16
0000b2  4388              BICS     r0,r0,r1
0000b4  6270              STR      r0,[r6,#0x24]
;;;573        return CLK_GetPLLClockFreq();
0000b6  f7fffffe          BL       CLK_GetPLLClockFreq
;;;574    }
0000ba  bdf8              POP      {r3-r7,pc}
                  |L8.188|
0000bc  4381              BICS     r1,r1,r0              ;568
0000be  6271              STR      r1,[r6,#0x24]         ;568
0000c0  e7f4              B        |L8.172|
;;;575    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L8.196|
                          DCD      0x00f42400
                  |L8.200|
                          DCD      0x02255100
                  |L8.204|
                          DCD      0x00b71b00
                  |L8.208|
                          DCD      0x50000200
                  |L8.212|
                          DCD      0x003d0900
                  |L8.216|
                          DCD      0x000f4240
                  |L8.220|
                          DCD      0xffffc0c0

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;614      */
;;;615    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b510              PUSH     {r4,lr}
;;;616    {
;;;617        SysTick->CTRL=0;
000002  4a09              LDR      r2,|L9.40|
000004  2300              MOVS     r3,#0
000006  6113              STR      r3,[r2,#0x10]
;;;618        if( u32ClkSrc== CLK_CLKSEL0_STCLKSEL_HCLK )    /* Set System Tick clock source */
;;;619            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
000008  2404              MOVS     r4,#4
00000a  2801              CMP      r0,#1                 ;618
;;;620        else
;;;621        {
;;;622            SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
00000c  6910              LDR      r0,[r2,#0x10]
00000e  d008              BEQ      |L9.34|
000010  43a0              BICS     r0,r0,r4
                  |L9.18|
000012  6110              STR      r0,[r2,#0x10]
;;;623        }
;;;624        SysTick->LOAD  = u32Count;                /* Set System Tick reload value */
000014  6151              STR      r1,[r2,#0x14]
;;;625        SysTick->VAL = 0;                         /* Clear System Tick current value and counter flag  */
000016  6193              STR      r3,[r2,#0x18]
;;;626        SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk; /* Set System Tick counter enabled */
000018  6910              LDR      r0,[r2,#0x10]
00001a  2101              MOVS     r1,#1
00001c  4308              ORRS     r0,r0,r1
00001e  6110              STR      r0,[r2,#0x10]
;;;627    }
000020  bd10              POP      {r4,pc}
                  |L9.34|
000022  4320              ORRS     r0,r0,r4              ;619
000024  e7f5              B        |L9.18|
;;;628    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0xe000e000

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;410      */
;;;411    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L10.12|
;;;412    {
;;;413        CLK->PWRCTL |= u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4302              ORRS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;414    }
000008  4770              BX       lr
;;;415    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;163      */
;;;164    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;167        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;168    }
00000a  bd10              POP      {r4,pc}
;;;169    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;124      */
;;;125    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;126    {
;;;127        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;128        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;129    }
00000a  bd10              POP      {r4,pc}
;;;130    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;98       */
;;;99     uint32_t CLK_GetHXTFreq(void)
000000  4802              LDR      r0,|L13.12|
;;;100    {
;;;101        if(CLK->PWRCTL & CLK_PWRCTL_HXT_EN )
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L13.10|
;;;102            return __HXT;
000008  4801              LDR      r0,|L13.16|
                  |L13.10|
;;;103        else
;;;104            return 0;
;;;105    }
00000a  4770              BX       lr
;;;106    
                          ENDP

                  |L13.12|
                          DCD      0x50000200
                  |L13.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;111      */
;;;112    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;113    {
;;;114        if(CLK->PWRCTL & CLK_PWRCTL_LXT_EN )
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  d502              BPL      |L14.14|
;;;115            return __LXT;
000008  2001              MOVS     r0,#1
00000a  03c0              LSLS     r0,r0,#15
;;;116        else
;;;117            return 0;
;;;118    }
00000c  4770              BX       lr
                  |L14.14|
00000e  2000              MOVS     r0,#0                 ;117
000010  4770              BX       lr
;;;119    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;135      */
;;;136    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;137    {
000002  b088              SUB      sp,sp,#0x20
;;;138        uint32_t Div[]= {1,2,4,8,16,1,1,1};
000004  2220              MOVS     r2,#0x20
000006  4909              LDR      r1,|L15.44|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;139        uint32_t PCLK_Div;
;;;140        PCLK_Div = CLK->APBDIV & CLK_APBDIV_APB0DIV_Msk;
00000e  4808              LDR      r0,|L15.48|
000010  6b40              LDR      r0,[r0,#0x34]
000012  0744              LSLS     r4,r0,#29
000014  0f64              LSRS     r4,r4,#29
;;;141        SystemCoreClockUpdate();
000016  f7fffffe          BL       SystemCoreClockUpdate
;;;142        return SystemCoreClock/Div[PCLK_Div];
00001a  00a0              LSLS     r0,r4,#2
00001c  4669              MOV      r1,sp
00001e  5809              LDR      r1,[r1,r0]
000020  4804              LDR      r0,|L15.52|
000022  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000024  f7fffffe          BL       __aeabi_uidivmod
;;;143    }
000028  b008              ADD      sp,sp,#0x20
00002a  bd10              POP      {r4,pc}
;;;144    
                          ENDP

                  |L15.44|
                          DCD      ||.constdata||
                  |L15.48|
                          DCD      0x50000200
                  |L15.52|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;149      */
;;;150    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;151    {
000002  b088              SUB      sp,sp,#0x20
;;;152        uint32_t Div[]= {1,2,4,8,16,1,1,1};
000004  2220              MOVS     r2,#0x20
000006  4909              LDR      r1,|L16.44|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;153        uint32_t PCLK_Div;
;;;154        PCLK_Div = CLK->APBDIV & CLK_APBDIV_APB1DIV_Msk;
00000e  4808              LDR      r0,|L16.48|
000010  6b44              LDR      r4,[r0,#0x34]
000012  2070              MOVS     r0,#0x70
000014  4004              ANDS     r4,r4,r0
;;;155        SystemCoreClockUpdate();
000016  f7fffffe          BL       SystemCoreClockUpdate
;;;156        return SystemCoreClock/Div[PCLK_Div];
00001a  00a0              LSLS     r0,r4,#2
00001c  4669              MOV      r1,sp
00001e  5809              LDR      r1,[r1,r0]
000020  4804              LDR      r0,|L16.52|
000022  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000024  f7fffffe          BL       __aeabi_uidivmod
;;;157    }
000028  b008              ADD      sp,sp,#0x20
00002a  bd10              POP      {r4,pc}
;;;158    
                          ENDP

                  |L16.44|
                          DCD      ||.constdata||+0x20
                  |L16.48|
                          DCD      0x50000200
                  |L16.52|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;174      */
;;;175    uint32_t CLK_GetPLLClockFreq(void)
000000  b510              PUSH     {r4,lr}
;;;176    {
;;;177        uint32_t u32Freq =0, u32PLLSrc;
;;;178        uint32_t u32SRC_N,u32PLL_M,u32PllReg;
;;;179    
;;;180        u32PllReg = CLK->PLLCTL;
000002  4b10              LDR      r3,|L17.68|
000004  6a5a              LDR      r2,[r3,#0x24]
;;;181    
;;;182        if (u32PllReg & CLK_PLLCTL_PD)
000006  03d0              LSLS     r0,r2,#15
000008  d501              BPL      |L17.14|
;;;183            return 0;    /* PLL is in power down mode */
00000a  2000              MOVS     r0,#0
;;;184    
;;;185        if((u32PllReg & CLK_PLLCTL_PLLSRC_Msk) == CLK_PLLCTL_PLL_SRC_HXT)
;;;186        {
;;;187            /* PLL source clock from HXT */
;;;188            u32PLLSrc = __HXT;
;;;189        }
;;;190        else if((u32PllReg & CLK_PLLCTL_PLLSRC_Msk) == CLK_PLLCTL_PLL_SRC_HIRC)
;;;191        {
;;;192            /* HIRC Source Selection */
;;;193            if(CLK->CLKSEL0 & CLK_CLKSEL0_HIRCSEL_Msk)
;;;194            {
;;;195                /* Clock source from HIRC1 (36MHz) */
;;;196                u32PLLSrc =__HIRC36M;
;;;197            }
;;;198            else
;;;199            {
;;;200                /* Clock source from HIRC0 (12MHz) */
;;;201                if(CLK->PWRCTL & CLK_PWRCTL_HIRC0FSEL_Msk)
;;;202                    u32PLLSrc =__HIRC16M;
;;;203                else
;;;204                    u32PLLSrc =__HIRC12M;
;;;205            }
;;;206        }
;;;207        else
;;;208        {
;;;209            /* PLL source clock from MIRC (4MHz) */
;;;210            u32PLLSrc =__MIRC;
;;;211        }
;;;212    
;;;213        u32SRC_N = (u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos;
;;;214        u32PLL_M = (u32PllReg & CLK_PLLCTL_PLLMLP_Msk) >> CLK_PLLCTL_PLLMLP_Pos;
;;;215    
;;;216        u32Freq = u32PLLSrc * u32PLL_M / (u32SRC_N+1);
;;;217    
;;;218        return u32Freq;
;;;219    }
00000c  bd10              POP      {r4,pc}
                  |L17.14|
00000e  0351              LSLS     r1,r2,#13             ;185
000010  480d              LDR      r0,|L17.72|
000012  0f8c              LSRS     r4,r1,#30             ;185
000014  d003              BEQ      |L17.30|
000016  0f89              LSRS     r1,r1,#30             ;190
000018  2901              CMP      r1,#1                 ;190
00001a  d009              BEQ      |L17.48|
00001c  480b              LDR      r0,|L17.76|
                  |L17.30|
00001e  0491              LSLS     r1,r2,#18             ;213
000020  0692              LSLS     r2,r2,#26             ;214
000022  0e89              LSRS     r1,r1,#26             ;213
000024  0e92              LSRS     r2,r2,#26             ;214
000026  4350              MULS     r0,r2,r0              ;216
000028  1c49              ADDS     r1,r1,#1              ;216
00002a  f7fffffe          BL       __aeabi_uidivmod
00002e  bd10              POP      {r4,pc}
                  |L17.48|
000030  6919              LDR      r1,[r3,#0x10]         ;193
000032  0709              LSLS     r1,r1,#28             ;193
000034  d501              BPL      |L17.58|
000036  4806              LDR      r0,|L17.80|
000038  e7f1              B        |L17.30|
                  |L17.58|
00003a  6819              LDR      r1,[r3,#0]            ;201
00003c  0489              LSLS     r1,r1,#18             ;201
00003e  d5ee              BPL      |L17.30|
000040  4804              LDR      r0,|L17.84|
000042  e7ec              B        |L17.30|
;;;220    
                          ENDP

                  |L17.68|
                          DCD      0x50000200
                  |L17.72|
                          DCD      0x00b71b00
                  |L17.76|
                          DCD      0x003d0900
                  |L17.80|
                          DCD      0x02255100
                  |L17.84|
                          DCD      0x00f42400

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;87       */
;;;88     void CLK_Idle(void)
000000  4803              LDR      r0,|L18.16|
;;;89     {
;;;90         CLK->PWRCTL &= ~(CLK_PWRCTL_PDEN_Msk);
000002  6801              LDR      r1,[r0,#0]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;91         __WFI();
00000a  bf30              WFI      
;;;92     }
00000c  4770              BX       lr
;;;93     
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;73       */
;;;74     void CLK_PowerDown(void)
000000  4904              LDR      r1,|L19.20|
;;;75     {
;;;76     
;;;77         SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
000002  2004              MOVS     r0,#4
000004  6108              STR      r0,[r1,#0x10]
;;;78         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk | CLK_PWRCTL_PDWKDLY_Msk);
000006  4804              LDR      r0,|L19.24|
000008  6801              LDR      r1,[r0,#0]
00000a  2250              MOVS     r2,#0x50
00000c  4311              ORRS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;79         __WFI();
000010  bf30              WFI      
;;;80     
;;;81     }
000012  4770              BX       lr
;;;82     
                          ENDP

                  |L19.20|
                          DCD      0xe000ed00
                  |L19.24|
                          DCD      0x50000200

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;225      */
;;;226    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b510              PUSH     {r4,lr}
;;;227    {
;;;228        if(CLK->PWRCTL & CLK_PWRCTL_HXT_EN)
000002  490e              LDR      r1,|L20.60|
000004  680a              LDR      r2,[r1,#0]
000006  07d2              LSLS     r2,r2,#31
000008  d002              BEQ      |L20.16|
;;;229            CLK_EnablePLL(CLK_PLLCTL_PLL_SRC_HXT, u32Hclk);
00000a  4601              MOV      r1,r0
00000c  2000              MOVS     r0,#0
00000e  e008              B        |L20.34|
                  |L20.16|
;;;230        else if(CLK->PWRCTL & (CLK_PWRCTL_HIRC0_EN | CLK_PWRCTL_HIRC1_EN))
000010  6809              LDR      r1,[r1,#0]
000012  4a0b              LDR      r2,|L20.64|
000014  4211              TST      r1,r2
;;;231            CLK_EnablePLL(CLK_PLLCTL_PLL_SRC_HIRC, u32Hclk);
;;;232        else
;;;233            CLK_EnablePLL(CLK_PLLCTL_PLL_SRC_MIRC, u32Hclk);
000016  4601              MOV      r1,r0
000018  d001              BEQ      |L20.30|
00001a  11d0              ASRS     r0,r2,#7              ;231
00001c  e001              B        |L20.34|
                  |L20.30|
00001e  2001              MOVS     r0,#1
000020  0480              LSLS     r0,r0,#18
                  |L20.34|
000022  f7fffffe          BL       CLK_EnablePLL
;;;234    
;;;235        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000026  2004              MOVS     r0,#4
000028  f7fffffe          BL       CLK_WaitClockReady
;;;236        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL,CLK_HCLK_CLK_DIVIDER(1));
00002c  2100              MOVS     r1,#0
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       CLK_SetHCLK
;;;237        return SystemCoreClock;
000034  4803              LDR      r0,|L20.68|
000036  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;238    }
000038  bd10              POP      {r4,pc}
;;;239    
                          ENDP

00003a  0000              DCW      0x0000
                  |L20.60|
                          DCD      0x50000200
                  |L20.64|
                          DCD      0x01000004
                  |L20.68|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;254      */
;;;255    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b510              PUSH     {r4,lr}
;;;256    {
;;;257        CLK->CLKDIV0 = (CLK->CLKDIV0 & ~CLK_CLKDIV0_HCLKDIV_Msk) | u32ClkDiv;
000002  4a07              LDR      r2,|L21.32|
000004  69d3              LDR      r3,[r2,#0x1c]
000006  091b              LSRS     r3,r3,#4
000008  011b              LSLS     r3,r3,#4
00000a  430b              ORRS     r3,r3,r1
00000c  61d3              STR      r3,[r2,#0x1c]
;;;258        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~(CLK_CLKSEL0_HIRCSEL_Msk | CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00000e  6911              LDR      r1,[r2,#0x10]
000010  0909              LSRS     r1,r1,#4
000012  0109              LSLS     r1,r1,#4
000014  4301              ORRS     r1,r1,r0
000016  6111              STR      r1,[r2,#0x10]
;;;259        SystemCoreClockUpdate();
000018  f7fffffe          BL       SystemCoreClockUpdate
;;;260    }
00001c  bd10              POP      {r4,pc}
;;;261    
                          ENDP

00001e  0000              DCW      0x0000
                  |L21.32|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;378    
;;;379    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;380    {
;;;381        uint32_t u32tmp=0,u32sel=0,u32div=0;
;;;382    
;;;383        if(MODULE_CLKDIV_Msk(u32ModuleIdx)!=MODULE_NoMsk)
000002  0a84              LSRS     r4,r0,#10
000004  0623              LSLS     r3,r4,#24
000006  0e1b              LSRS     r3,r3,#24
000008  d00c              BEQ      |L22.36|
;;;384        {
;;;385            u32div =(uint32_t)&CLK->CLKDIV0+((MODULE_CLKDIV(u32ModuleIdx))*4);
00000a  0303              LSLS     r3,r0,#12
00000c  0f9b              LSRS     r3,r3,#30
00000e  4d0f              LDR      r5,|L22.76|
000010  009b              LSLS     r3,r3,#2
000012  195b              ADDS     r3,r3,r5
;;;386            u32tmp = *(volatile uint32_t *)(u32div);
000014  681d              LDR      r5,[r3,#0]
;;;387            u32tmp = ( u32tmp & ~(MODULE_CLKDIV_Msk(u32ModuleIdx)<<MODULE_CLKDIV_Pos(u32ModuleIdx)) ) | u32ClkDiv;
000016  0586              LSLS     r6,r0,#22
000018  b2e4              UXTB     r4,r4
00001a  0ef6              LSRS     r6,r6,#27
00001c  40b4              LSLS     r4,r4,r6
00001e  43a5              BICS     r5,r5,r4
000020  4315              ORRS     r5,r5,r2
;;;388            *(volatile uint32_t *)(u32div) = u32tmp;
000022  601d              STR      r5,[r3,#0]
                  |L22.36|
;;;389        }
;;;390    
;;;391        if(MODULE_CLKSEL_Msk(u32ModuleIdx)!=MODULE_NoMsk)
000024  0e42              LSRS     r2,r0,#25
000026  0712              LSLS     r2,r2,#28
000028  d00e              BEQ      |L22.72|
;;;392        {
;;;393            u32sel = (uint32_t)&CLK->CLKSEL0+((MODULE_CLKSEL(u32ModuleIdx))*4);
00002a  0042              LSLS     r2,r0,#1
00002c  4b07              LDR      r3,|L22.76|
00002e  0f92              LSRS     r2,r2,#30
000030  0092              LSLS     r2,r2,#2
000032  3b0c              SUBS     r3,r3,#0xc
000034  18d2              ADDS     r2,r2,r3
;;;394            u32tmp = *(volatile uint32_t *)(u32sel);
000036  6813              LDR      r3,[r2,#0]
;;;395            u32tmp = ( u32tmp & ~(MODULE_CLKSEL_Msk(u32ModuleIdx)<<MODULE_CLKSEL_Pos(u32ModuleIdx)) ) | u32ClkSrc;
000038  00c4              LSLS     r4,r0,#3
00003a  0f24              LSRS     r4,r4,#28
00003c  01c0              LSLS     r0,r0,#7
00003e  0ec0              LSRS     r0,r0,#27
000040  4084              LSLS     r4,r4,r0
000042  43a3              BICS     r3,r3,r4
000044  430b              ORRS     r3,r3,r1
;;;396            *(volatile uint32_t *)(u32sel) = u32tmp;
000046  6013              STR      r3,[r2,#0]
                  |L22.72|
;;;397        }
;;;398    }
000048  bd70              POP      {r4-r6,pc}
;;;399    
                          ENDP

00004a  0000              DCW      0x0000
                  |L22.76|
                          DCD      0x5000021c

                          AREA ||i.CLK_SetPCLK0||, CODE, READONLY, ALIGN=2

                  CLK_SetPCLK0 PROC
;;;271      */
;;;272    void CLK_SetPCLK0(uint32_t u32ClkDiv)
000000  4903              LDR      r1,|L23.16|
;;;273    {
;;;274        CLK->APBDIV = (CLK->APBDIV & ~CLK_APBDIV_APB0DIV_Msk) | u32ClkDiv;
000002  6b4a              LDR      r2,[r1,#0x34]
000004  08d2              LSRS     r2,r2,#3
000006  00d2              LSLS     r2,r2,#3
000008  4302              ORRS     r2,r2,r0
00000a  634a              STR      r2,[r1,#0x34]
;;;275    }
00000c  4770              BX       lr
;;;276    
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      0x50000200

                          AREA ||i.CLK_SetPCLK1||, CODE, READONLY, ALIGN=2

                  CLK_SetPCLK1 PROC
;;;286      */
;;;287    void CLK_SetPCLK1(uint32_t u32ClkDiv)
000000  4a03              LDR      r2,|L24.16|
;;;288    {
;;;289        CLK->APBDIV = (CLK->APBDIV & ~CLK_APBDIV_APB1DIV_Msk) | u32ClkDiv;
000002  6b51              LDR      r1,[r2,#0x34]
000004  2370              MOVS     r3,#0x70
000006  4399              BICS     r1,r1,r3
000008  4301              ORRS     r1,r1,r0
00000a  6351              STR      r1,[r2,#0x34]
;;;290    }
00000c  4770              BX       lr
;;;291    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x50000200

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;593      */
;;;594    void CLK_SysTickDelay(uint32_t us)
000000  4906              LDR      r1,|L25.28|
;;;595    {
;;;596        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4348              MULS     r0,r1,r0
000006  4906              LDR      r1,|L25.32|
000008  6148              STR      r0,[r1,#0x14]
;;;597        SysTick->VAL  =  (0x00);
00000a  2200              MOVS     r2,#0
00000c  618a              STR      r2,[r1,#0x18]
;;;598        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L25.18|
;;;599    
;;;600        /* Waiting for down-count to zero */
;;;601        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L25.18|
;;;602        SysTick->CTRL = 0;
000018  610a              STR      r2,[r1,#0x10]
;;;603    }
00001a  4770              BX       lr
;;;604    
                          ENDP

                  |L25.28|
                          DCD      CyclesPerUs
                  |L25.32|
                          DCD      0xe000e000

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;654      */
;;;655    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;656    {
000002  4604              MOV      r4,r0
;;;657        int32_t i32TimeOutCnt=2160000;
000004  4907              LDR      r1,|L26.36|
;;;658    
;;;659        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000006  4b08              LDR      r3,|L26.40|
000008  e005              B        |L26.22|
                  |L26.10|
;;;660        {
;;;661            if(i32TimeOutCnt-- <= 0)
00000a  460a              MOV      r2,r1
00000c  1e49              SUBS     r1,r1,#1
00000e  2a00              CMP      r2,#0
000010  dc01              BGT      |L26.22|
;;;662                return 0;
000012  2000              MOVS     r0,#0
;;;663        }
;;;664        return 1;
;;;665    }
000014  bd10              POP      {r4,pc}
                  |L26.22|
000016  68da              LDR      r2,[r3,#0xc]          ;659
000018  4620              MOV      r0,r4                 ;659
00001a  4390              BICS     r0,r0,r2              ;659
00001c  d1f5              BNE      |L26.10|
00001e  2001              MOVS     r0,#1                 ;664
000020  bd10              POP      {r4,pc}
;;;666    
                          ENDP

000022  0000              DCW      0x0000
                  |L26.36|
                          DCD      0x0020f580
                  |L26.40|
                          DCD      0x50000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
