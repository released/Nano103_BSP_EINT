; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Nano103\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\timer.crf ..\..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;72       */
;;;73     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;74     {
;;;75         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;76         timer->INTEN = 0;
000004  60c1              STR      r1,[r0,#0xc]
;;;77     }
000006  4770              BX       lr
;;;78     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;86       */
;;;87     void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;88     {
000002  b081              SUB      sp,sp,#4
000004  4605              MOV      r5,r0
;;;89         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4606              MOV      r6,r0
;;;90         uint32_t u32Prescale = 0, delay = SystemCoreClock / u32Clk;
00000c  4601              MOV      r1,r0
00000e  4819              LDR      r0,|L2.116|
000010  2700              MOVS     r7,#0
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  f7fffffe          BL       __aeabi_uidivmod
000018  4604              MOV      r4,r0
;;;91         long long u64Cmpr;
;;;92     
;;;93         // Clear current timer configuration
;;;94         timer->CTL = 0;
00001a  2000              MOVS     r0,#0
00001c  6028              STR      r0,[r5,#0]
;;;95     
;;;96         if(u32Clk == 10000)           // min delay is 100us if timer clock source is LIRC 10k
00001e  4816              LDR      r0,|L2.120|
000020  4286              CMP      r6,r0
000022  d106              BNE      |L2.50|
;;;97         {
;;;98             u32Usec = ((u32Usec + 99) / 100) * 100;
000024  9802              LDR      r0,[sp,#8]
000026  2164              MOVS     r1,#0x64
000028  3063              ADDS     r0,r0,#0x63
00002a  f7fffffe          BL       __aeabi_uidivmod
00002e  2164              MOVS     r1,#0x64
000030  e005              B        |L2.62|
                  |L2.50|
;;;99         }
;;;100        else        // 10 usec every step
;;;101        {
;;;102            u32Usec = ((u32Usec + 9) / 10) * 10;
000032  9802              LDR      r0,[sp,#8]
000034  210a              MOVS     r1,#0xa
000036  3009              ADDS     r0,r0,#9
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  210a              MOVS     r1,#0xa
                  |L2.62|
00003e  4348              MULS     r0,r1,r0
;;;103        }
;;;104    
;;;105        if(u32Clk > 0xFFFFFF)   // For Nano103, only needs to consider 32MHz at most
000040  490e              LDR      r1,|L2.124|
000042  428e              CMP      r6,r1
000044  d901              BLS      |L2.74|
;;;106        {
;;;107            u32Prescale = 1;
000046  2701              MOVS     r7,#1
;;;108            u32Clk >>= 1;
000048  0876              LSRS     r6,r6,#1
                  |L2.74|
;;;109        }
;;;110    
;;;111        // u32Usec * u32Clk might overflow if using uint32_t
;;;112        u64Cmpr = (long long)u32Usec * (long long)u32Clk / (long long)1000000;
00004a  4631              MOV      r1,r6
00004c  f7fffffe          BL       __ARM_common_ll_muluu
000050  4a0b              LDR      r2,|L2.128|
000052  2300              MOVS     r3,#0
000054  f7fffffe          BL       __aeabi_ldivmod
;;;113    
;;;114        timer->CMP = (uint32_t)u64Cmpr;
000058  60a8              STR      r0,[r5,#8]
;;;115        timer->PRECNT = u32Prescale;
00005a  606f              STR      r7,[r5,#4]
;;;116        timer->CTL = TIMER_CTL_CNTEN_Msk; // one shot mode
00005c  2001              MOVS     r0,#1
00005e  6028              STR      r0,[r5,#0]
;;;117    
;;;118        // When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;119        // And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag.
;;;120        for(; delay > 0; delay--)
000060  2c00              CMP      r4,#0
000062  d002              BEQ      |L2.106|
                  |L2.100|
;;;121        {
;;;122            __NOP();
000064  bf00              NOP      
000066  1e64              SUBS     r4,r4,#1
000068  d1fc              BNE      |L2.100|
                  |L2.106|
;;;123        }
;;;124    
;;;125        while(timer->CTL & TIMER_CTL_ACTSTS_Msk);
00006a  6828              LDR      r0,[r5,#0]
00006c  0600              LSLS     r0,r0,#24
00006e  d4fc              BMI      |L2.106|
;;;126    
;;;127    }
000070  bdfe              POP      {r1-r7,pc}
;;;128    
                          ENDP

000072  0000              DCW      0x0000
                  |L2.116|
                          DCD      SystemCoreClock
                  |L2.120|
                          DCD      0x00002710
                  |L2.124|
                          DCD      0x00ffffff
                  |L2.128|
                          DCD      0x000f4240

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;157      */
;;;158    void TIMER_DisableCapture(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;159    {
;;;160        timer->CTL &= ~TIMER_CTL_CAPEN_Msk;
000002  2201              MOVS     r2,#1
000004  0412              LSLS     r2,r2,#16
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;161    
;;;162    }
00000a  4770              BX       lr
;;;163    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;183      */
;;;184    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;185    {
;;;186        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  2201              MOVS     r2,#1
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;187    }
00000a  4770              BX       lr
;;;188    
                          ENDP


                          AREA ||i.TIMER_DisableFreqCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableFreqCounter PROC
;;;305      */
;;;306    void TIMER_DisableFreqCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;307    {
;;;308        timer->CTL &= ~(TIMER_CTL_INTRTGEN_Msk | TIMER_CTL_INTRTGMD_Msk);
000002  2203              MOVS     r2,#3
000004  0612              LSLS     r2,r2,#24
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;309    }
00000a  4770              BX       lr
;;;310    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;143      */
;;;144    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;145    {
;;;146    
;;;147        timer->CTL = (timer->CTL & ~(TIMER_CTL_CAPFUNCS_Msk |
000002  6803              LDR      r3,[r0,#0]
000004  240f              MOVS     r4,#0xf
000006  0464              LSLS     r4,r4,#17
000008  43a3              BICS     r3,r3,r4
00000a  430b              ORRS     r3,r3,r1
00000c  2101              MOVS     r1,#1
00000e  4313              ORRS     r3,r3,r2
000010  0409              LSLS     r1,r1,#16
000012  430b              ORRS     r3,r3,r1
000014  6003              STR      r3,[r0,#0]
;;;148                                     TIMER_CTL_CAPCNTMD_Msk |
;;;149                                     TIMER_CTL_CAPEDGE_Msk)) |
;;;150                     u32CapMode | u32Edge | TIMER_CTL_CAPEN_Msk;
;;;151    }
000016  bd10              POP      {r4,pc}
;;;152    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;172      */
;;;173    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6802              LDR      r2,[r0,#0]
;;;174    {
;;;175        timer->CTL = (timer->CTL & ~TIMER_CTL_CNTPHASE_Msk) | u32Edge;
000002  2301              MOVS     r3,#1
000004  035b              LSLS     r3,r3,#13
000006  439a              BICS     r2,r2,r3
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;176        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000c  6801              LDR      r1,[r0,#0]
00000e  105a              ASRS     r2,r3,#1
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;177    }
000014  4770              BX       lr
;;;178    
                          ENDP


                          AREA ||i.TIMER_EnableFreqCounter||, CODE, READONLY, ALIGN=2

                  TIMER_EnableFreqCounter PROC
;;;278      */
;;;279    void TIMER_EnableFreqCounter(TIMER_T *timer,
000000  b510              PUSH     {r4,lr}
;;;280                                 uint32_t u32DropCount,
;;;281                                 uint32_t u32Timeout,
;;;282                                 uint32_t u32EnableInt)
;;;283    {
;;;284        uint32_t mode = TIMER_CTL_INTRTGEN_Msk;
000002  2401              MOVS     r4,#1
000004  0624              LSLS     r4,r4,#24
;;;285        TIMER_T *t;    // store the timer base to configure compare value
;;;286    
;;;287        if(u32DropCount != 0 || u32Timeout >= 2)
000006  2900              CMP      r1,#0
000008  d101              BNE      |L8.14|
00000a  2a02              CMP      r2,#2
00000c  d303              BCC      |L8.22|
                  |L8.14|
;;;288            mode |= TIMER_CTL_INTRTGMD_Msk;
00000e  2403              MOVS     r4,#3
000010  0624              LSLS     r4,r4,#24
;;;289        if(u32Timeout < 2)
000012  2a02              CMP      r2,#2
000014  d200              BCS      |L8.24|
                  |L8.22|
;;;290            u32Timeout = 0xFFFFFF;
000016  4a0a              LDR      r2,|L8.64|
                  |L8.24|
;;;291    
;;;292        timer->ECTL = u32DropCount << TIMER_ECTL_EVNTDPCNT_Pos;
000018  0609              LSLS     r1,r1,#24
00001a  6201              STR      r1,[r0,#0x20]
;;;293        t = (timer == TIMER0) ? TIMER1 : TIMER3;
00001c  4909              LDR      r1,|L8.68|
00001e  4288              CMP      r0,r1
000020  d101              BNE      |L8.38|
000022  4909              LDR      r1,|L8.72|
000024  e000              B        |L8.40|
                  |L8.38|
000026  4909              LDR      r1,|L8.76|
                  |L8.40|
;;;294    
;;;295        t->CMP = u32Timeout;
000028  608a              STR      r2,[r1,#8]
;;;296        t->INTEN = u32EnableInt ? TIMER_INTEN_CAPIEN_Msk : 0;
00002a  2b00              CMP      r3,#0
00002c  d001              BEQ      |L8.50|
00002e  2202              MOVS     r2,#2
000030  e000              B        |L8.52|
                  |L8.50|
000032  2200              MOVS     r2,#0
                  |L8.52|
000034  60ca              STR      r2,[r1,#0xc]
;;;297        timer->CTL = mode | TIMER_CTL_CNTEN_Msk;
000036  2101              MOVS     r1,#1
000038  430c              ORRS     r4,r4,r1
00003a  6004              STR      r4,[r0,#0]
;;;298    
;;;299        return;
;;;300    }
00003c  bd10              POP      {r4,pc}
;;;301    /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      0x00ffffff
                  |L8.68|
                          DCD      0x40010000
                  |L8.72|
                          DCD      0x40010100
                  |L8.76|
                          DCD      0x40110100

                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;194      */
;;;195    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b51f              PUSH     {r0-r4,lr}
;;;196    {
;;;197        uint32_t u32Src, u32Div;
;;;198        const uint32_t au32Clk[] = {__HXT, __LXT, __LIRC, 0};   // we don't know actual clock if external pin is clock source, set to 0 here
000002  4925              LDR      r1,|L9.152|
000004  c91e              LDM      r1,{r1-r4}
;;;199    
;;;200        if(timer == TIMER0)
000006  9403              STR      r4,[sp,#0xc]
000008  466c              MOV      r4,sp
00000a  c40e              STM      r4!,{r1-r3}
00000c  4a23              LDR      r2,|L9.156|
;;;201        {
;;;202            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
00000e  4924              LDR      r1,|L9.160|
000010  4290              CMP      r0,r2                 ;200
000012  d105              BNE      |L9.32|
000014  6948              LDR      r0,[r1,#0x14]
;;;203            u32Div = (CLK->CLKDIV1 & CLK_CLKDIV1_TMR0DIV_Msk) >> CLK_CLKDIV1_TMR0DIV_Pos;
000016  6a0a              LDR      r2,[r1,#0x20]
;;;204        }
;;;205        else if(timer == TIMER1)
;;;206        {
;;;207            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
;;;208            u32Div = (CLK->CLKDIV1 & CLK_CLKDIV1_TMR1DIV_Msk) >> CLK_CLKDIV1_TMR1DIV_Pos;
;;;209        }
;;;210        else if(timer == TIMER2)
;;;211        {
;;;212            u32Src = (CLK->CLKSEL2 & CLK_CLKSEL2_TMR2SEL_Msk) >> CLK_CLKSEL2_TMR2SEL_Pos;
;;;213            u32Div = (CLK->CLKDIV1 & CLK_CLKDIV1_TMR2DIV_Msk) >> CLK_CLKDIV1_TMR2DIV_Pos;
;;;214        }
;;;215        else    // Timer 3
;;;216        {
;;;217            u32Src = (CLK->CLKSEL2 & CLK_CLKSEL2_TMR3SEL_Msk) >> CLK_CLKSEL2_TMR3SEL_Pos;
;;;218            u32Div = (CLK->CLKDIV1 & CLK_CLKDIV1_TMR3DIV_Msk) >> CLK_CLKDIV1_TMR3DIV_Pos;
;;;219        }
;;;220        u32Div++;
;;;221        if(u32Src < 4)
;;;222            return au32Clk[u32Src] / u32Div;
;;;223        else if(u32Src == 4)
;;;224        {
;;;225            /* HIRC Source Selection */
;;;226            if(CLK->CLKSEL0 & CLK_CLKSEL0_HIRCSEL_Msk)
;;;227            {
;;;228                /* Clock source from HIRC1 (36MHz) */
;;;229                return __HIRC36M / u32Div;
;;;230            }
;;;231            else
;;;232            {
;;;233                /* Clock source from HIRC0 (12MHz) */
;;;234                if(CLK->PWRCTL & CLK_PWRCTL_HIRC0FSEL_Msk)
;;;235                    return __HIRC16M / u32Div;
;;;236                else
;;;237                    return __HIRC12M / u32Div;
;;;238            }
;;;239    
;;;240        }
;;;241        else if(u32Src == 5)     // MIRC
;;;242        {
;;;243            return __MIRC / u32Div;
;;;244    
;;;245        }
;;;246        else    // HCLK
;;;247            return CLK_GetHCLKFreq() / u32Div;
;;;248    
;;;249    }
000018  0540              LSLS     r0,r0,#21
00001a  0f40              LSRS     r0,r0,#29
00001c  0a12              LSRS     r2,r2,#8
00001e  e016              B        |L9.78|
                  |L9.32|
000020  4a20              LDR      r2,|L9.164|
000022  4290              CMP      r0,r2                 ;205
000024  d106              BNE      |L9.52|
000026  6948              LDR      r0,[r1,#0x14]         ;207
000028  6a0a              LDR      r2,[r1,#0x20]         ;208
00002a  0440              LSLS     r0,r0,#17
00002c  0f40              LSRS     r0,r0,#29
00002e  0412              LSLS     r2,r2,#16             ;208
000030  0f14              LSRS     r4,r2,#28             ;208
000032  e00e              B        |L9.82|
                  |L9.52|
000034  4a1c              LDR      r2,|L9.168|
000036  4290              CMP      r0,r2                 ;210
000038  6988              LDR      r0,[r1,#0x18]         ;217
00003a  d104              BNE      |L9.70|
00003c  0540              LSLS     r0,r0,#21
00003e  6a0a              LDR      r2,[r1,#0x20]         ;213
000040  0f40              LSRS     r0,r0,#29
000042  0c12              LSRS     r2,r2,#16
000044  e003              B        |L9.78|
                  |L9.70|
000046  0440              LSLS     r0,r0,#17
000048  6a0a              LDR      r2,[r1,#0x20]         ;218
00004a  0f40              LSRS     r0,r0,#29
00004c  0d12              LSRS     r2,r2,#20
                  |L9.78|
00004e  0714              LSLS     r4,r2,#28
000050  0f24              LSRS     r4,r4,#28
                  |L9.82|
000052  1c64              ADDS     r4,r4,#1
000054  2804              CMP      r0,#4                 ;221
000056  d203              BCS      |L9.96|
000058  0081              LSLS     r1,r0,#2              ;222
00005a  4668              MOV      r0,sp                 ;222
00005c  5840              LDR      r0,[r0,r1]            ;222
00005e  e005              B        |L9.108|
                  |L9.96|
000060  2804              CMP      r0,#4                 ;223
000062  d008              BEQ      |L9.118|
000064  2805              CMP      r0,#5                 ;241
000066  d014              BEQ      |L9.146|
000068  f7fffffe          BL       CLK_GetHCLKFreq
                  |L9.108|
00006c  4621              MOV      r1,r4                 ;222
                  |L9.110|
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  b004              ADD      sp,sp,#0x10
000074  bd10              POP      {r4,pc}
                  |L9.118|
000076  6908              LDR      r0,[r1,#0x10]         ;226
000078  0700              LSLS     r0,r0,#28             ;226
00007a  d502              BPL      |L9.130|
00007c  4621              MOV      r1,r4                 ;229
00007e  480b              LDR      r0,|L9.172|
000080  e7f5              B        |L9.110|
                  |L9.130|
000082  6808              LDR      r0,[r1,#0]            ;234
000084  4621              MOV      r1,r4                 ;237
000086  0480              LSLS     r0,r0,#18             ;234
000088  d501              BPL      |L9.142|
00008a  4809              LDR      r0,|L9.176|
00008c  e7ef              B        |L9.110|
                  |L9.142|
00008e  4809              LDR      r0,|L9.180|
000090  e7ed              B        |L9.110|
                  |L9.146|
000092  4621              MOV      r1,r4                 ;243
000094  4808              LDR      r0,|L9.184|
000096  e7ea              B        |L9.110|
;;;250    
                          ENDP

                  |L9.152|
                          DCD      ||.constdata||
                  |L9.156|
                          DCD      0x40010000
                  |L9.160|
                          DCD      0x50000200
                  |L9.164|
                          DCD      0x40010100
                  |L9.168|
                          DCD      0x40110000
                  |L9.172|
                          DCD      0x02255100
                  |L9.176|
                          DCD      0x00f42400
                  |L9.180|
                          DCD      0x00b71b00
                  |L9.184|
                          DCD      0x003d0900

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=2

                  TIMER_Open PROC
;;;40       */
;;;41     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;42     {
000002  4617              MOV      r7,r2
000004  4606              MOV      r6,r0
;;;43         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4604              MOV      r4,r0
;;;44         uint32_t u32Cmpr = 0, u32Prescale = 0;
00000c  2500              MOVS     r5,#0
;;;45     
;;;46         // Fastest possible timer working freq is u32Clk / 2. While cmpr = 2, pre-scale = 0
;;;47         if(u32Freq > (u32Clk / 2))
00000e  0840              LSRS     r0,r0,#1
000010  42b8              CMP      r0,r7
000012  d201              BCS      |L10.24|
;;;48         {
;;;49             u32Cmpr = 2;
000014  2002              MOVS     r0,#2
000016  e008              B        |L10.42|
                  |L10.24|
;;;50         }
;;;51         else
;;;52         {
;;;53             if(u32Clk > 0xFFFFFF)   // For Nano103, only needs to consider 36MHz at most
000018  4909              LDR      r1,|L10.64|
00001a  428c              CMP      r4,r1
00001c  d901              BLS      |L10.34|
;;;54             {
;;;55                 u32Prescale = 1;
00001e  2501              MOVS     r5,#1
;;;56                 u32Clk >>= 1;
000020  4604              MOV      r4,r0
                  |L10.34|
;;;57             }
;;;58             u32Cmpr = u32Clk / u32Freq;
000022  4639              MOV      r1,r7
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       __aeabi_uidivmod
                  |L10.42|
;;;59         }
;;;60         timer->CMP = u32Cmpr;
00002a  60b0              STR      r0,[r6,#8]
;;;61         timer->PRECNT = u32Prescale;
00002c  6075              STR      r5,[r6,#4]
;;;62         timer->CTL = u32Mode;
00002e  9901              LDR      r1,[sp,#4]
000030  6031              STR      r1,[r6,#0]
000032  1c6d              ADDS     r5,r5,#1
;;;63     
;;;64     
;;;65         return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
000034  4368              MULS     r0,r5,r0
000036  4601              MOV      r1,r0
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       __aeabi_uidivmod
;;;66     }
00003e  bdfe              POP      {r1-r7,pc}
;;;67     
                          ENDP

                  |L10.64|
                          DCD      0x00ffffff

                          AREA ||i.TIMER_ResetCounter||, CODE, READONLY, ALIGN=1

                  TIMER_ResetCounter PROC
;;;255      */
;;;256    void TIMER_ResetCounter(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;257    {
;;;258        // A write with any value to TIMER CNT register will trigger timer counter reset
;;;259        timer->CNT = 0;
000002  6141              STR      r1,[r0,#0x14]
;;;260    }
000004  4770              BX       lr
;;;261    
                          ENDP


                          AREA ||i.TIMER_SetTriggerSource||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerSource PROC
;;;318      */
;;;319    void TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src)
000000  6802              LDR      r2,[r0,#0]
;;;320    {
;;;321        timer->CTL = (timer->CTL & ~TIMER_CTL_TRGSSEL_Msk) | u32Src;
000002  2301              MOVS     r3,#1
000004  02db              LSLS     r3,r3,#11
000006  439a              BICS     r2,r2,r3
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;322    }
00000c  4770              BX       lr
;;;323    
                          ENDP


                          AREA ||i.TIMER_SetTriggerTarget||, CODE, READONLY, ALIGN=2

                  TIMER_SetTriggerTarget PROC
;;;332      */
;;;333    void TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;334    {
;;;335        timer->CTL = (timer->CTL & ~(TIMER_CTL_TRGPWM_Msk | TIMER_CTL_TRGPDMA_Msk | TIMER_CTL_TRGADC_Msk)) | u32Mask;
000002  4b02              LDR      r3,|L13.12|
000004  401a              ANDS     r2,r2,r3
000006  430a              ORRS     r2,r2,r1
000008  6002              STR      r2,[r0,#0]
;;;336    }
00000a  4770              BX       lr
;;;337    
                          ENDP

                  |L13.12|
                          DCD      0xeffffaff

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00002710
                          DCD      0x00000000

                          AREA ||i.__ARM_common_ll_muluu||, COMGROUP=__ARM_common_ll_muluu, CODE, READONLY, ALIGN=1

                  __ARM_common_ll_muluu PROC
000000  b5f8              PUSH     {r3-r7,lr}
000002  0c04              LSRS     r4,r0,#16
000004  b28b              UXTH     r3,r1
000006  4626              MOV      r6,r4
000008  b282              UXTH     r2,r0
00000a  435e              MULS     r6,r3,r6
00000c  0c0d              LSRS     r5,r1,#16
00000e  4610              MOV      r0,r2
000010  0c37              LSRS     r7,r6,#16
000012  4358              MULS     r0,r3,r0
000014  0436              LSLS     r6,r6,#16
000016  1980              ADDS     r0,r0,r6
000018  2100              MOVS     r1,#0
00001a  4179              ADCS     r1,r1,r7
00001c  4616              MOV      r6,r2
00001e  436e              MULS     r6,r5,r6
000020  0c37              LSRS     r7,r6,#16
000022  0436              LSLS     r6,r6,#16
000024  1980              ADDS     r0,r0,r6
000026  4179              ADCS     r1,r1,r7
000028  4626              MOV      r6,r4
00002a  436e              MULS     r6,r5,r6
00002c  1989              ADDS     r1,r1,r6
00002e  bdf8              POP      {r3-r7,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 402
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
