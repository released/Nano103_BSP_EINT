; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Nano103\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\uart.crf ..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearIntFlag PROC
;;;97      */
;;;98     void UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag)
000000  074a              LSLS     r2,r1,#29
;;;99     {
000002  d503              BPL      |L1.12|
;;;100    
;;;101        if(u32InterruptFlag & UART_INTSTS_RLSIF_Msk)   /* clear Receive Line Status Interrupt */
;;;102        {
;;;103            uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
000004  2270              MOVS     r2,#0x70
000006  6182              STR      r2,[r0,#0x18]
;;;104            uart->TRSR = UART_TRSR_ADDRDETF_Msk;
000008  2201              MOVS     r2,#1
00000a  6142              STR      r2,[r0,#0x14]
                  |L1.12|
;;;105        }
;;;106    
;;;107        if(u32InterruptFlag & UART_INTSTS_MODEMIF_Msk)  /* clear Modem Interrupt */
00000c  070a              LSLS     r2,r1,#28
00000e  d504              BPL      |L1.26|
;;;108            uart->MODEM |= UART_MODEM_CTSDETF_Msk;
000010  69c2              LDR      r2,[r0,#0x1c]
000012  2301              MOVS     r3,#1
000014  049b              LSLS     r3,r3,#18
000016  431a              ORRS     r2,r2,r3
000018  61c2              STR      r2,[r0,#0x1c]
                  |L1.26|
;;;109    
;;;110        if(u32InterruptFlag & UART_INTSTS_BUFERRIF_Msk)   /* clear Buffer Error Interrupt */
00001a  068a              LSLS     r2,r1,#26
00001c  d502              BPL      |L1.36|
;;;111        {
;;;112            uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
00001e  22ff              MOVS     r2,#0xff
000020  3202              ADDS     r2,#2
000022  6182              STR      r2,[r0,#0x18]
                  |L1.36|
;;;113        }
;;;114    
;;;115        if(u32InterruptFlag & UART_INTSTS_WKUPIF_Msk)   /* clear wake up Interrupt */
000024  064a              LSLS     r2,r1,#25
000026  d501              BPL      |L1.44|
;;;116        {
;;;117            uart->INTSTS = UART_INTSTS_WKUPIF_Msk;
000028  2240              MOVS     r2,#0x40
00002a  6102              STR      r2,[r0,#0x10]
                  |L1.44|
;;;118        }
;;;119    
;;;120        if(u32InterruptFlag & UART_INTSTS_ABRIF_Msk)   /* clear auto-baud rate Interrupt */
00002c  060a              LSLS     r2,r1,#24
00002e  d501              BPL      |L1.52|
;;;121        {
;;;122            uart->TRSR = UART_TRSR_ABRDTOIF_Msk | UART_TRSR_ABRDIF_Msk;
000030  2206              MOVS     r2,#6
000032  6142              STR      r2,[r0,#0x14]
                  |L1.52|
;;;123        }
;;;124    
;;;125        if(u32InterruptFlag & UART_INTSTS_LINIF_Msk)   /* clear LIN break Interrupt */
000034  05c9              LSLS     r1,r1,#23
000036  d501              BPL      |L1.60|
;;;126        {
;;;127            uart->TRSR = UART_TRSR_LINTXIF_Msk | UART_TRSR_LINRXIF_Msk | UART_TRSR_BITEF_Msk;
000038  2138              MOVS     r1,#0x38
00003a  6141              STR      r1,[r0,#0x14]
                  |L1.60|
;;;128        }
;;;129    
;;;130    }
00003c  4770              BX       lr
;;;131    
                          ENDP


                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;139     */
;;;140    void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;141    {
;;;142        uart->INTEN = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;143    }
000004  4770              BX       lr
;;;144    
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;152     */
;;;153    void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;154    {
;;;155        uart->CTRL &= ~(UART_CTRL_ATORTSEN_Msk | UART_CTRL_ATOCTSEN_Msk);
000002  2230              MOVS     r2,#0x30
000004  4391              BICS     r1,r1,r2
000006  6041              STR      r1,[r0,#4]
;;;156    }
000008  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;176     */
;;;177    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  68c2              LDR      r2,[r0,#0xc]
;;;178    {
;;;179        uart->INTEN &= ~ u32InterruptFlag;
000002  438a              BICS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;180    }
000006  4770              BX       lr
;;;181    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=2

                  UART_EnableFlowCtrl PROC
;;;190     */
;;;191    void UART_EnableFlowCtrl(UART_T* uart )
000000  69c1              LDR      r1,[r0,#0x1c]
;;;192    {
;;;193        uart->MODEM |= UART_MODEM_RTSACTLV_Msk | UART_MODEM_CTSACTLV_Msk;
000002  4a04              LDR      r2,|L5.20|
000004  4311              ORRS     r1,r1,r2
000006  61c1              STR      r1,[r0,#0x1c]
;;;194        uart->CTRL |= UART_CTRL_ATORTSEN_Msk | UART_CTRL_ATOCTSEN_Msk;
000008  6841              LDR      r1,[r0,#4]
00000a  2230              MOVS     r2,#0x30
00000c  4311              ORRS     r1,r1,r2
00000e  6041              STR      r1,[r0,#4]
;;;195    }
000010  4770              BX       lr
;;;196    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x00010001

                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;215     */
;;;216    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  68c2              LDR      r2,[r0,#0xc]
;;;217    {
;;;218        uart->INTEN |= u32InterruptFlag;
000002  430a              ORRS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;219    }
000006  4770              BX       lr
;;;220    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;229     */
;;;230    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  b570              PUSH     {r4-r6,lr}
;;;231    {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;232        uint32_t u32Baud_Div;
;;;233        uint32_t u32SrcFreq;
;;;234    
;;;235        u32SrcFreq = _UART_GetUartClk(uart);
000006  f7fffffe          BL       _UART_GetUartClk
00000a  4605              MOV      r5,r0
;;;236    
;;;237        uart->CTRL &= ~(UART_CTRL_RXOFF_Msk | UART_CTRL_TXOFF_Msk);
00000c  6860              LDR      r0,[r4,#4]
00000e  210c              MOVS     r1,#0xc
000010  4388              BICS     r0,r0,r1
000012  6060              STR      r0,[r4,#4]
;;;238    
;;;239        uart->FUNCSEL = UART_FUNCSEL_UART;
000014  2000              MOVS     r0,#0
000016  63a0              STR      r0,[r4,#0x38]
;;;240        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1 |
000018  2003              MOVS     r0,#3
00001a  60a0              STR      r0,[r4,#8]
;;;241                     UART_LINE_RFITL_1BYTE | UART_LINE_RTS_TRI_LEV_1BYTE;
;;;242    
;;;243        if(u32baudrate != 0)
00001c  2e00              CMP      r6,#0
00001e  d013              BEQ      |L7.72|
;;;244        {
;;;245            u32Baud_Div = UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32baudrate);
000020  0870              LSRS     r0,r6,#1
000022  1940              ADDS     r0,r0,r5
000024  4631              MOV      r1,r6
000026  f7fffffe          BL       __aeabi_uidivmod
;;;246    
;;;247            if(u32Baud_Div > 0xFFFF)
00002a  4908              LDR      r1,|L7.76|
00002c  1e40              SUBS     r0,r0,#1
00002e  4288              CMP      r0,r1
000030  d909              BLS      |L7.70|
;;;248                uart->BAUD = (UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32baudrate));
000032  00f0              LSLS     r0,r6,#3
000034  1940              ADDS     r0,r0,r5
000036  4631              MOV      r1,r6
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  2101              MOVS     r1,#1
00003e  0900              LSRS     r0,r0,#4
000040  07c9              LSLS     r1,r1,#31
000042  1e40              SUBS     r0,r0,#1
000044  4308              ORRS     r0,r0,r1
                  |L7.70|
;;;249            else
;;;250                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
000046  6260              STR      r0,[r4,#0x24]
                  |L7.72|
;;;251        }
;;;252    }
000048  bd70              POP      {r4-r6,pc}
;;;253    
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;264     */
;;;265    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
000002  4604              MOV      r4,r0
;;;267        uint32_t  u32Count, u32delayno;
;;;268    
;;;269        for(u32Count=0; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;270        {
;;;271            u32delayno = 0;
;;;272    
;;;273            while(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;274            {
;;;275                u32delayno++;
;;;276                if( u32delayno >= 0x40000000 )
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L8.38|
                  |L8.12|
00000c  2300              MOVS     r3,#0                 ;271
00000e  e004              B        |L8.26|
                  |L8.16|
000010  1c5b              ADDS     r3,r3,#1              ;273
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L8.26|
;;;277                    return FALSE;
000016  2000              MOVS     r0,#0
;;;278            }
;;;279            pu8RxBuf[u32Count] = uart->DAT;    /* Get Data from UART RX  */
;;;280        }
;;;281    
;;;282        return u32Count;
;;;283    
;;;284    }
000018  bd70              POP      {r4-r6,pc}
                  |L8.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;273
00001c  07b6              LSLS     r6,r6,#30             ;273
00001e  d4f7              BMI      |L8.16|
000020  6823              LDR      r3,[r4,#0]            ;279
000022  540b              STRB     r3,[r1,r0]            ;279
000024  1c40              ADDS     r0,r0,#1              ;279
                  |L8.38|
000026  4290              CMP      r0,r2                 ;269
000028  d3f0              BCC      |L8.12|
00002a  bd70              POP      {r4-r6,pc}
;;;285    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=1

                  UART_SelectIrDAMode PROC
;;;343     */
;;;344    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b570              PUSH     {r4-r6,lr}
;;;345    {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;346        uint32_t u32SrcFreq;
;;;347    
;;;348        u32SrcFreq = _UART_GetUartClk(uart);
000008  f7fffffe          BL       _UART_GetUartClk
;;;349    
;;;350        uart->BAUD = UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32Buadrate);
00000c  00e9              LSLS     r1,r5,#3
00000e  1808              ADDS     r0,r1,r0
000010  4629              MOV      r1,r5
000012  f7fffffe          BL       __aeabi_uidivmod
000016  2101              MOVS     r1,#1
000018  0900              LSRS     r0,r0,#4
00001a  07c9              LSLS     r1,r1,#31
00001c  1e40              SUBS     r0,r0,#1
00001e  4308              ORRS     r0,r0,r1
000020  6260              STR      r0,[r4,#0x24]
;;;351    
;;;352        uart->IRDA    &=  ~UART_IRDA_TXINV_Msk;
000022  6b20              LDR      r0,[r4,#0x30]
000024  2120              MOVS     r1,#0x20
000026  4388              BICS     r0,r0,r1
000028  6320              STR      r0,[r4,#0x30]
;;;353        uart->IRDA |=     UART_IRDA_RXINV_Msk;
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  2140              MOVS     r1,#0x40
00002e  4308              ORRS     r0,r0,r1
000030  6320              STR      r0,[r4,#0x30]
;;;354        uart->IRDA    = u32Direction ? uart->IRDA | UART_IRDA_TXEN_Msk : uart->IRDA &~ UART_IRDA_TXEN_Msk;
000032  2102              MOVS     r1,#2
000034  6b20              LDR      r0,[r4,#0x30]
000036  2e00              CMP      r6,#0
000038  d001              BEQ      |L9.62|
00003a  4308              ORRS     r0,r0,r1
00003c  e000              B        |L9.64|
                  |L9.62|
00003e  4388              BICS     r0,r0,r1
                  |L9.64|
000040  6320              STR      r0,[r4,#0x30]
;;;355        uart->FUNCSEL = (0x2 << UART_FUNCSEL_FUNCSEL_Pos);
000042  63a1              STR      r1,[r4,#0x38]
;;;356    }
000044  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP


                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;388     */
;;;389    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  b510              PUSH     {r4,lr}
;;;390    {
;;;391        /* Select LIN function mode */
;;;392        uart->FUNCSEL = UART_FUNCSEL_LIN;
000002  2301              MOVS     r3,#1
000004  6383              STR      r3,[r0,#0x38]
;;;393    
;;;394        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;395        uart->FUNCSEL = UART_FUNCSEL_LIN;
000006  6383              STR      r3,[r0,#0x38]
;;;396        uart->ALTCTL &= ~(UART_ALTCTL_BRKFL_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_LINTXEN_Msk);
000008  6b43              LDR      r3,[r0,#0x34]
00000a  24c7              MOVS     r4,#0xc7
00000c  43a3              BICS     r3,r3,r4
00000e  6343              STR      r3,[r0,#0x34]
;;;397        uart->ALTCTL |= u32BreakLength & UART_ALTCTL_BRKFL_Msk;
000010  6b43              LDR      r3,[r0,#0x34]
000012  0752              LSLS     r2,r2,#29
000014  0f52              LSRS     r2,r2,#29
000016  4313              ORRS     r3,r3,r2
000018  6343              STR      r3,[r0,#0x34]
;;;398        uart->ALTCTL |= u32Mode;
00001a  6b42              LDR      r2,[r0,#0x34]
00001c  430a              ORRS     r2,r2,r1
00001e  6342              STR      r2,[r0,#0x34]
;;;399    }
000020  bd10              POP      {r4,pc}
;;;400    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=1

                  UART_SelectRS485Mode PROC
;;;367     */
;;;368    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  2303              MOVS     r3,#3
;;;369    {
;;;370        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  6383              STR      r3,[r0,#0x38]
;;;371        uart->ALTCTL = 0;
000004  2300              MOVS     r3,#0
000006  6343              STR      r3,[r0,#0x34]
;;;372        uart->ALTCTL |= u32Mode | (u32Addr << UART_ALTCTL_ADRMPID_Pos);
000008  6b43              LDR      r3,[r0,#0x34]
00000a  0612              LSLS     r2,r2,#24
00000c  430a              ORRS     r2,r2,r1
00000e  4313              ORRS     r3,r3,r2
000010  6343              STR      r3,[r0,#0x34]
;;;373    }
000012  4770              BX       lr
;;;374    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;298     */
;;;299    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;300    {
000002  b081              SUB      sp,sp,#4
000004  4617              MOV      r7,r2
000006  460d              MOV      r5,r1
000008  4606              MOV      r6,r0
;;;301        uint32_t u32Baud_Div = 0;
;;;302        uint32_t u32SrcFreq;
;;;303    
;;;304        u32SrcFreq = _UART_GetUartClk(uart);
00000a  f7fffffe          BL       _UART_GetUartClk
00000e  4604              MOV      r4,r0
;;;305    
;;;306        if(u32baudrate != 0)
000010  2d00              CMP      r5,#0
000012  d013              BEQ      |L12.60|
;;;307        {
;;;308            u32Baud_Div = UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32baudrate);
000014  0868              LSRS     r0,r5,#1
000016  1900              ADDS     r0,r0,r4
000018  4629              MOV      r1,r5
00001a  f7fffffe          BL       __aeabi_uidivmod
;;;309    
;;;310            if(u32Baud_Div > 0xFFFF)
00001e  490b              LDR      r1,|L12.76|
000020  1e40              SUBS     r0,r0,#1
000022  4288              CMP      r0,r1
000024  d909              BLS      |L12.58|
;;;311                uart->BAUD = (UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32baudrate));
000026  00e8              LSLS     r0,r5,#3
000028  1900              ADDS     r0,r0,r4
00002a  4629              MOV      r1,r5
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  2101              MOVS     r1,#1
000032  0900              LSRS     r0,r0,#4
000034  07c9              LSLS     r1,r1,#31
000036  1e40              SUBS     r0,r0,#1
000038  4308              ORRS     r0,r0,r1
                  |L12.58|
;;;312            else
;;;313                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
00003a  6270              STR      r0,[r6,#0x24]
                  |L12.60|
;;;314        }
;;;315    
;;;316        uart->LINE = u32data_width | u32parity | u32stop_bits;
00003c  9804              LDR      r0,[sp,#0x10]
00003e  4307              ORRS     r7,r7,r0
000040  980a              LDR      r0,[sp,#0x28]
000042  4307              ORRS     r7,r7,r0
000044  60b7              STR      r7,[r6,#8]
;;;317    }
000046  b005              ADD      sp,sp,#0x14
000048  bdf0              POP      {r4-r7,pc}
;;;318    
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;327     */
;;;328    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;329    {
;;;330        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk)| (u32TOC);
000002  0a52              LSRS     r2,r2,#9
000004  0252              LSLS     r2,r2,#9
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;331        uart->INTEN |= UART_INTEN_RXTOIEN_Msk;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  2210              MOVS     r2,#0x10
00000e  4311              ORRS     r1,r1,r2
000010  60c1              STR      r1,[r0,#0xc]
;;;332    }
000012  4770              BX       lr
;;;333    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;409     */
;;;410    uint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;411    {
000002  4604              MOV      r4,r0
;;;412        uint32_t  u32Count, u32delayno;
;;;413    
;;;414        for(u32Count=0; u32Count != u32WriteBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;415        {
;;;416            u32delayno = 0;
;;;417            while((uart->FIFOSTS & UART_FIFOSTS_TXEMPTY_Msk) == 0)   /* Wait Tx empty and Time-out manner */
;;;418            {
;;;419                u32delayno++;
;;;420                if( u32delayno >= 0x40000000 )
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L14.38|
                  |L14.12|
00000c  2300              MOVS     r3,#0                 ;416
00000e  e004              B        |L14.26|
                  |L14.16|
000010  1c5b              ADDS     r3,r3,#1              ;417
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L14.26|
;;;421                    return FALSE;
000016  2000              MOVS     r0,#0
;;;422            }
;;;423            uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;424        }
;;;425    
;;;426        return u32Count;
;;;427    
;;;428    }
000018  bd70              POP      {r4-r6,pc}
                  |L14.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;417
00001c  05b6              LSLS     r6,r6,#22             ;417
00001e  d5f7              BPL      |L14.16|
000020  5c0b              LDRB     r3,[r1,r0]            ;423
000022  6023              STR      r3,[r4,#0]            ;423
000024  1c40              ADDS     r0,r0,#1              ;423
                  |L14.38|
000026  4290              CMP      r0,r2                 ;414
000028  d1f0              BNE      |L14.12|
00002a  bd70              POP      {r4-r6,pc}
;;;429    
                          ENDP


                          AREA ||i._UART_GetUartClk||, CODE, READONLY, ALIGN=2

                  _UART_GetUartClk PROC
;;;29       */
;;;30     uint32_t _UART_GetUartClk(UART_T* uart)
000000  b510              PUSH     {r4,lr}
;;;31     {
;;;32         uint8_t u8UartClkSrcSel = 0;
;;;33         uint32_t clk =0, div = 1;
;;;34     
;;;35         if(uart == UART0)
000002  4b1a              LDR      r3,|L15.108|
000004  2200              MOVS     r2,#0                 ;32
000006  2401              MOVS     r4,#1                 ;33
;;;36         {
;;;37             u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
000008  4919              LDR      r1,|L15.112|
00000a  4298              CMP      r0,r3                 ;35
00000c  d106              BNE      |L15.28|
00000e  6948              LDR      r0,[r1,#0x14]
000010  0742              LSLS     r2,r0,#29
;;;38             div = ( (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos) + 1; /* Get uart clock divider */
000012  69c8              LDR      r0,[r1,#0x1c]
000014  0f52              LSRS     r2,r2,#29             ;37
;;;39         }
;;;40         else if(uart == UART1)
;;;41         {
;;;42             u8UartClkSrcSel = (CLK->CLKSEL2 & CLK_CLKSEL2_UART1SEL_Msk) >> CLK_CLKSEL2_UART1SEL_Pos;
;;;43             div = ( (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos) + 1; /* Get uart clock divider */
;;;44         }
;;;45     
;;;46         switch (u8UartClkSrcSel)   /* Get uart selected clock source */
;;;47         {
;;;48         case 0:
;;;49             clk = __HXT; /* HXT */
;;;50             break;
;;;51         case 1:
;;;52             clk = __LXT;  /* LXT */
;;;53             break;
;;;54         case 2:
;;;55             clk = SysGet_PLLClockFreq(); /* PLL */
;;;56             break;
;;;57         case 3:
;;;58             if(CLK->CLKSEL0 & CLK_CLKSEL0_HIRCSEL_Msk)
;;;59                 clk = __HIRC36M; /* HIRC 36M Hz*/
;;;60             else
;;;61             {
;;;62                 if(CLK->PWRCTL & CLK_PWRCTL_HIRC0FSEL_Msk)
;;;63                     clk = __HIRC16M; /* HIRC 16M Hz*/
;;;64                 else
;;;65                     clk = __HIRC12M; /* HIRC 12M Hz*/
;;;66             }
;;;67             break;
;;;68     
;;;69         default:
;;;70             clk = __MIRC;
;;;71             break;
;;;72     
;;;73         }
;;;74     
;;;75         clk /= div; /* calculate uart clock */
;;;76     
;;;77         return clk;
;;;78     }
000016  0500              LSLS     r0,r0,#20
000018  0f04              LSRS     r4,r0,#28
00001a  e008              B        |L15.46|
                  |L15.28|
00001c  4b15              LDR      r3,|L15.116|
00001e  4298              CMP      r0,r3                 ;40
000020  d106              BNE      |L15.48|
000022  6988              LDR      r0,[r1,#0x18]         ;42
000024  0742              LSLS     r2,r0,#29             ;42
000026  69c8              LDR      r0,[r1,#0x1c]         ;43
000028  0f52              LSRS     r2,r2,#29             ;42
00002a  0400              LSLS     r0,r0,#16             ;43
00002c  0f04              LSRS     r4,r0,#28             ;43
                  |L15.46|
00002e  1c64              ADDS     r4,r4,#1              ;43
                  |L15.48|
000030  4811              LDR      r0,|L15.120|
000032  2a00              CMP      r2,#0                 ;46
000034  d006              BEQ      |L15.68|
000036  2a01              CMP      r2,#1                 ;46
000038  d008              BEQ      |L15.76|
00003a  2a02              CMP      r2,#2                 ;46
00003c  d009              BEQ      |L15.82|
00003e  2a03              CMP      r2,#3                 ;46
000040  d00a              BEQ      |L15.88|
000042  480e              LDR      r0,|L15.124|
                  |L15.68|
000044  4621              MOV      r1,r4                 ;75
000046  f7fffffe          BL       __aeabi_uidivmod
00004a  bd10              POP      {r4,pc}
                  |L15.76|
00004c  2001              MOVS     r0,#1                 ;52
00004e  03c0              LSLS     r0,r0,#15             ;52
000050  e7f8              B        |L15.68|
                  |L15.82|
000052  f7fffffe          BL       SysGet_PLLClockFreq
000056  e7f5              B        |L15.68|
                  |L15.88|
000058  690a              LDR      r2,[r1,#0x10]         ;58
00005a  0712              LSLS     r2,r2,#28             ;58
00005c  d501              BPL      |L15.98|
00005e  4808              LDR      r0,|L15.128|
000060  e7f0              B        |L15.68|
                  |L15.98|
000062  6809              LDR      r1,[r1,#0]            ;62
000064  0489              LSLS     r1,r1,#18             ;62
000066  d5ed              BPL      |L15.68|
000068  4806              LDR      r0,|L15.132|
00006a  e7eb              B        |L15.68|
;;;79     
                          ENDP

                  |L15.108|
                          DCD      0x40050000
                  |L15.112|
                          DCD      0x50000200
                  |L15.116|
                          DCD      0x40150000
                  |L15.120|
                          DCD      0x00b71b00
                  |L15.124|
                          DCD      0x003d0900
                  |L15.128|
                          DCD      0x02255100
                  |L15.132|
                          DCD      0x00f42400

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_803b14af____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_803b14af____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_803b14af____REVSH|
#line 402
|__asm___6_uart_c_803b14af____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
